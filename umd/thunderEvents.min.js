(function(g,f){typeof exports==='object'&&typeof module!=='undefined'?module.exports=f():typeof define==='function'&&define.amd?define(f):(g=typeof globalThis!=='undefined'?globalThis:g||self,g.ThunderEvents=f());})(this,(function(){'use strict';const DEFAULT_FLOOR_PLAN = {
  title: 'Venue',
  imageSrc: '',
  dimensions: {
    height: 600,
    width: 800
  },
  clickableAreas: []
};
const DEFAULT_GUIDE = {
  locations: [],
  events: [],
  floorPlan: DEFAULT_FLOOR_PLAN,
  rollOverTime: '12:00 AM'
};
const FAVORITES_KEY = 'FAVORITE_EVENTS';
const DEFAULT_ADD_FAVORITE = async event => {
  const favoriteEvents = JSON.parse(localStorage.getItem(FAVORITES_KEY) || '[]');
  favoriteEvents.push(event);
  const eventsJSON = JSON.stringify(favoriteEvents);
  localStorage.setItem(FAVORITES_KEY, eventsJSON);
  return favoriteEvents;
};
const DEFAULT_REMOVE_FAVORITE = async event => {
  const favoriteEvents = JSON.parse(localStorage.getItem(FAVORITES_KEY) || '[]');
  const removeIndex = favoriteEvents.findIndex(({
    location: _location,
    start,
    name
  }) => {
    const {
      location: cLocation,
      start: cStart,
      name: cName
    } = event;
    return _location === cLocation && start === cStart && name === cName;
  });
  favoriteEvents.splice(removeIndex, 1);
  const eventsJSON = JSON.stringify(favoriteEvents);
  localStorage.setItem(FAVORITES_KEY, eventsJSON);
  return favoriteEvents;
};
const DEFAULT_GET_FAVORITES = async () => {
  const favoriteEvents = JSON.parse(localStorage.getItem(FAVORITES_KEY) || '[]');
  return favoriteEvents;
};
const DEFAULT_FETCH_DATA = () => Promise.resolve({
  guide: DEFAULT_GUIDE,
  addFavorite: DEFAULT_ADD_FAVORITE,
  getFavorites: DEFAULT_GET_FAVORITES
});
const NOW = Date.now(); // date in milliseconds

const HOUR = 1000 * 60 * 60; // milliseconds * seconds * minutes

const DEFAULT_EVENT = {
  start: NOW,
  end: NOW + HOUR,
  location: '(not provided)',
  name: '(no name)',
  host: '(not provided)',
  category: '(not provided)',
  description: '(no description)'
};
const DEFAULT_CLICKABLE_AREA = {
  location: '(none)',
  shape: 'rect',
  coords: [],
  href: '#',
  alt: ''
};
const NOOP = () => {};const getType = val => {
  if (val === null) return 'null';
  if (typeof val === 'object') return val.constructor.name.toLowerCase();
  return typeof val;
};
const checkType = (val, type) => {
  const validString = getType(type) === 'string';
  const validArray = getType(type) === 'array' && type.every(t => getType(t) === 'string');
  if (!validString && !validArray) throw '`checkType()` expects either a string or array of strings in the second argument';
  if (validString) return getType(val) === type;
  if (validArray) return type.some(t => getType(val) === t);
};
const isObject = obj => checkType(obj, 'object');
const isEmpty = val => checkType(val, ['undefined', 'null']);
/**
 * Returns a function which gets a field from a given object, unless it's empty,
 * in which case it gets that same field from a fallback object.
 * @param {object} fallbackObj - The object to be referenced when a field is empty on the original object.
 * @param {function} onFallback - An optional callback to run when the fallback is used.
 * @param {object} _altTypes - A mapping of fields to acceptable alternative types.
 * @returns {function} - Used to get the value from a provided key.
 */

const useFallback = (fallbackObj, onFallback = NOOP, _altTypes = {}) => {
  if (!isObject(fallbackObj)) throw '`useFallback()` expects an object in the first argument';
  if (!checkType(onFallback, 'function')) throw '`useFallback()` expects a function in the second argument';
  if (!isObject(_altTypes)) throw '`useFallback()` expects an object in the third argument';
  return (obj, key) => {
    const fallbackValue = fallbackObj[key];
    const valid = isObject(obj);
    const value = valid ? obj[key] : null;
    const empty = isEmpty(value);
    const type = getType(value);
    const altTypes = _altTypes[key];
    const altTypesArr = checkType(altTypes, 'array') ? altTypes : checkType(altTypes, 'string') ? [altTypes] : [];
    const mismatch = type !== getType(fallbackValue) && !altTypesArr.some(t => t === type);

    if (!valid || empty || mismatch) {
      const status = !valid ? 'invalid' : empty ? 'empty' : 'mismatch';
      onFallback(status, key);
      return fallbackValue;
    }

    return value;
  };
};
/**
 * Returns a function which casts any value to the same structure as the provided object (the type).
 * @param {object} type - An object which serves as the (shallow) structure constraints.
 * @param {string} name - The optional name of the type for logging purposes.
 * @param {object} altTypes - A mapping of fields to acceptable alternative types.
 * @returns {function} - Used to cast a provided value to the given type.
 */

const useCast = (type, name = 'object', altTypes = {}) => {
  if (!isObject(type)) throw 'You may only cast to custom object types';
  return obj => {
    if (!isObject(obj)) return type;
    const getValue = useFallback(type, (status, key) => {
      if (status === 'invalid') console.warn(`The provided ${name} is not a valid object.`);else if (status === 'mismatch') console.warn(`The \`${key}\` field expected type \`${getType(type[key])}\` but got \`${getType(obj[key])}\`.`);else if (status === 'empty') console.warn(`The provided ${name} did not have the \`${key}\` field.`);
    }, altTypes);
    return Object.keys(type).reduce((castObj, key) => {
      castObj[key] = getValue(obj, key);
      return castObj;
    }, {});
  };
};
const checkFilterType = (filter = {}) => {
  if ('after' in filter && !checkType(filter.after, ['number', 'date'])) throw 'The `after` field expects a number or date';
  if ('before' in filter && !checkType(filter.before, ['number', 'date'])) throw 'The `before` field expects a number or date';
  if ('locations' in filter && !checkType(filter.locations, 'array')) throw 'The `locations` field expects an array';
  if ('search' in filter && !checkType(filter.search, ['string', 'regexp'])) throw 'The `search` field expects a string or regular expression';
  return true; // indicate success
};
/**
 * Rounds a date to the nearest given minute
 * @param {Date|number|string} _date - The date to round (or anything that can be parsed as a date)
 * @param {number} nearestMinute - The nearest minute to round to (15 by default)
 */

const roundMinutes = (_date, nearestMinute = 15) => {
  const date = new Date(_date);
  const roundedMinutes = Math.round(date.getMinutes() / nearestMinute) * nearestMinute;
  date.setMinutes(roundedMinutes);
  return date;
};
/**
 * Gets the name of the day based on the index (typically returned by `date.getDay()`)
 * @param {number} idx - The index of the day of the week
 * @param {boolean} short - Whether to abbreviate the day names or not
 * @returns {string} - The name of the day of the week
 */

const getDay = (idx, short = false) => {
  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  const shortDays = ['Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat'];
  return short ? shortDays[idx] : days[idx];
};
const getLastTimeInThreshold = (currentDate, allDates, threshold = '12:00 AM') => {
  const lastInCurrentDay = Math.max(...allDates.filter(t => t.getDate() === currentDate.getDate()));
  if (threshold === '12:00 AM') return new Date(lastInCurrentDay);
  const nextDate = new Date(currentDate);
  nextDate.setDate(currentDate.getDate() + 1);
  nextDate.setTime(new Date(`${nextDate.toLocaleDateString()} ${threshold}`).getTime());
  const allTimesNextDay = allDates.filter(t => t.getDate() === nextDate.getDate());
  const lastInNextDay = Math.max(...allTimesNextDay.filter(t => t.getTime() <= nextDate.getTime()));
  return new Date(lastInNextDay > 0 ? lastInNextDay : lastInCurrentDay);
};const state = {
  // utilities for synchronous actions after loading state
  _hasFetched: false,

  get hasFetched() {
    return this._hasFetched;
  },

  set hasFetched(bool) {
    this._hasFetched = bool;
    if (bool === false) return false;
    this.fetchQueue.forEach(resolve => resolve());
    return true;
  },

  fetchQueue: [],

  waitForFetch() {
    return new Promise(resolve => {
      if (this.hasFetched) resolve();else this.fetchQueue.push(() => resolve());
    });
  },

  // default guide
  guide: DEFAULT_GUIDE,
  // default favorite functionality
  addFavorite: DEFAULT_ADD_FAVORITE,
  removeFavorite: DEFAULT_REMOVE_FAVORITE,
  getFavorites: DEFAULT_GET_FAVORITES,

  // get locations and add any missed from events dynamically
  get locations() {
    const locations = this.guide?.locations ?? [];
    const events = this.guide?.events ?? [];
    return [...events.reduce((locations, event) => {
      if (!checkType(event, 'object')) return locations;
      if (!checkType(event.location, 'string')) return locations;
      if (!locations.has(event.location)) locations.add(event.location);
      return locations;
    }, new Set(locations))];
  },

  // get times from events dynamically
  get times() {
    const events = this.guide?.events ?? [];
    const threshold = this.guide?.rollOverTime ?? '12:00 AM';
    const allTimes = [...events.reduce((times, event) => {
      if (!checkType(event, 'object')) return times;
      if (!checkType(event.start, ['number', 'date'])) return times;
      if (!checkType(event.end, ['number', 'date'])) return times;
      times.add(roundMinutes(event.start));
      times.add(roundMinutes(event.end));
      return times;
    }, new Set())].sort();
    const earliestTime = new Date(Math.min(...allTimes));
    const latestTime = new Date(Math.max(...allTimes));
    const interval = allTimes.reduce((interval, date) => {
      if (interval !== 15) {
        const minutes = date.getMinutes();
        if (minutes === 30) interval = 30;
        if (minutes === 15 || minutes === 45) interval = 15;
      }

      return interval;
    }, 0);

    const getTimeObject = date => ({
      date,
      timeString: date.toLocaleTimeString('en-US', {
        timeStyle: 'short'
      })
    });

    const getFullDay = time => `${getDay(time.getDay())} ${time.toLocaleDateString()}`;

    let days = {
      [getFullDay(earliestTime)]: [getTimeObject(earliestTime)]
    };
    let prevTime = earliestTime;
    let currentDay = getFullDay(prevTime);

    while (prevTime < latestTime) {
      const lastTimeInDay = getLastTimeInThreshold(prevTime, allTimes, threshold);
      let currentTime = null;

      if (Number(lastTimeInDay) === Number(prevTime)) {
        currentTime = new Date(allTimes.find(time => time > prevTime));
        currentDay = getFullDay(currentTime);
        days[currentDay] = [getTimeObject(currentTime)];
      } else {
        currentTime = new Date(prevTime);
        const intervalInMs = interval * 1000 * 60;
        currentTime.setTime(currentTime.getTime() + intervalInMs);
        days[currentDay].push(getTimeObject(currentTime));
      }

      prevTime = currentTime;
    }

    return {
      days,
      interval
    };
  }

};// with imports between two separate bundles.

const getState = () => {
  globalThis.__thunderEvents__sharedState = globalThis.__thunderEvents__sharedState // existing state
  ?? state; // initialize if none exists already

  return globalThis.__thunderEvents__sharedState;
};

const init = async (init = DEFAULT_FETCH_DATA) => {
  const state = getState();
  const data = await init();
  if (!isObject(data)) throw '`init()` must return an object';
  const {
    guide
  } = data;
  if (!isObject(guide)) throw 'The `guide` field expects an object';

  if ('events' in guide) {
    if (!checkType(guide.events, 'array')) throw 'The `guide.events` field expects an array';
    const castEvent = useCast(DEFAULT_EVENT, 'event', {
      start: 'date',
      end: 'date'
    });
    state.guide.events = guide.events.map(castEvent);
  }

  if ('floorPlan' in guide) {
    if (!isObject(guide.floorPlan)) throw 'The `guide.floorPlan` field expects an object';
    const castFloorPlan = useCast(DEFAULT_FLOOR_PLAN, 'floor plan');
    const castClickableArea = useCast(DEFAULT_CLICKABLE_AREA, 'clickable area');
    const floorPlan = castFloorPlan(guide.floorPlan);
    state.guide.floorPlan = { ...floorPlan,
      clickableAreas: floorPlan.clickableAreas.map(castClickableArea)
    };
  }

  if ('locations' in guide) {
    if (!checkType(guide.events, 'array')) throw 'The `guide.locations` field expects an array';
    state.guide.locations = guide.locations.map(loc => String(loc));
  }

  if ('rollOverTime' in guide) {
    if (!checkType(guide.rollOverTime, 'string')) throw 'The `guide.rollOverTime` field expects a string';
    const timeRegex = /(^((1[0-2])|0?[1-9]):\d{2} (AM|PM)$)|(^(([0-1]?[0-9])|(2[0-3])):\d{2}$)/;
    if (!timeRegex.test(guide.rollOverTime)) throw 'The `guide.rollOverTime` field expects the string in time format.  Example: "1:00 PM" for 12-hours or "13:00" for 24-hours';
    state.guide.rollOverTime = guide.rollOverTime;
  }

  if ('addFavorite' in data) {
    if (!checkType(data.addFavorite, 'function')) throw 'The `addFavorite` field expects a function';
    state.addFavorite = data.addFavorite;
  }

  if ('removeFavorite' in data) {
    if (!checkType(data.removeFavorite, 'function')) throw 'The `removeFavorite` field expects a function';
    state.removeFavorite = data.removeFavorite;
  }

  if ('getFavorites' in data) {
    if (!checkType(data.getFavorites, 'function')) throw 'The `getFavorites` field expects a function';
    state.getFavorites = data.getFavorites;
  }

  state.hasFetched = true;
};

const getEvents = async (_filters = {}) => {
  const state = getState();
  await state.waitForFetch();
  if (!isObject(_filters)) throw '`getEvents()` expects an object in the first argument';
  const {
    include: _include = {},
    exclude: _exclude = {}
  } = _filters;
  checkFilterType(_include); // throws if invalid

  checkFilterType(_exclude); // throws if invalid

  const filters = { ..._filters,
    include: { ..._include,
      after: _include.after ? Number(_include.after) : 0,
      before: _include.before ? Number(_include.before) : Infinity
    },
    exclude: { ..._exclude,
      after: _exclude.after ? Number(_exclude.after) : Infinity,
      before: _exclude.before ? Number(_exclude.before) : 0
    }
  };
  const {
    include = {},
    exclude = {}
  } = filters;
  return state.guide.events.filter(event => {
    // filter within time range
    if (event.start < include.after) return false;
    if (event.start > exclude.after) return false;
    if (event.end > include.before) return false;
    if (event.end < exclude.before) return false; // filter by location

    if ('locations' in include && !contains(include.locations, event.location)) return false;
    if ('locations' in exclude && contains(exclude.locations, event.location)) return false; // filter by name

    if ('search' in include && !contains(event.name, include.search)) return false;
    if ('search' in exclude && contains(event.name, exclude.search)) return false; // if all previous checks pass, keep this event in the array

    return true;
  });
};

const getLocations = async () => {
  const state = getState();
  await state.waitForFetch();
  return state.locations;
};

const getTimes = async () => {
  const state = getState();
  await state.waitForFetch();
  return state.times;
};

const getFloorPlan = async () => {
  const state = getState();
  await state.waitForFetch();
  return state.guide.floorPlan;
};

const addFavorite = async event => {
  const state = getState();
  const favorites = await state.addFavorite(event);
  return favorites;
};

const removeFavorite = async event => {
  const state = getState();
  const favorites = await state.removeFavorite(event);
  return favorites;
};

const getFavorites = async () => {
  const state = getState();
  const favorites = await state.getFavorites();
  return favorites;
};var Exports=/*#__PURE__*/Object.freeze({__proto__:null,init:init,addFavorite:addFavorite,removeFavorite:removeFavorite,getFavorites:getFavorites,getEvents:getEvents,getLocations:getLocations,getTimes:getTimes,getFloorPlan:getFloorPlan});return Exports;}));